---
import { Image } from 'astro:assets';
import CartesianGrid from '../images/cartesian-grid.svg';
import DashedRectangle from '../images/dashed-rectangle.svg';
import RagStackElephant from '../images/rag-stack-elephant.svg';
import MLStackElephant from '../images/ml-stack-elephant.svg';
import VectorDBStackElephant from '../images/vectordb-stack-elephant.svg';
import MongoAlternativeStackElephant from '../images/mongoalternative-stack-elephant.svg';
import GeospatialStackElephant from '../images/geospatial-stack-elephant.svg';
import DataWareHouseStackElephant from '../images/datawarehouse-stack-elephant.svg';
import MQStackElephant from '../images/mq-stack-elephant.svg';
import StandardStackElephant from '../images/standard-stack-elephant.svg';
import TimeseriesStackElephant from '../images/timeseries-stack-elephant.svg';
import OLTPStackElephant from '../images/oltp-stack-elephant.svg';
import OLAPStackElephant from '../images/olap-stack-elephant.svg';
import { styles } from '../util';

const STACK_HERO_CARDS_DETAILS_1 = [
	{
		title: 'Data Warehouse',
		description:
			'Extract, Transform and Load data from external sources. Build centralized datastore for analytical and tactical queries',
		image: DataWareHouseStackElephant,
		url: 'https://tembo.io/docs/product/stacks/analytical/data-warehouse',
	},
	{
		title: 'Message Queue',
		description:
			'An alternative to AWS SQS and Redis RSMQ, on Postgres. Interface to Postgres queues using SQL, REST API, and many client libraries including Python, Rust, and Go.',
		image: MQStackElephant,
		url: 'https://tembo.io/docs/product/stacks/transactional/message-queue',
	},
	{
		title: 'VectorDB',
		description:
			'Store, index, retrieve, and generate embeddings in Postgres.',
		image: VectorDBStackElephant,
		url: 'https://tembo.io/docs/product/stacks/ai/vectordb/getting-started',
	},
	{
		title: 'Timeseries',
		description:
			'Efficiently store and query data indexed by time, optimizing performance for chronological data analysis in real-time monitoring and trend forecasting',
		image: TimeseriesStackElephant,
		url: 'https://tembo.io/docs/product/stacks/analytical/timeseries',
	},
	{
		title: 'Retrieval Augmented Generation',
		description: 'LLM function calling directly from Postgres.',
		image: RagStackElephant,
		url: 'https://tembo.io/docs/product/stacks/ai/rag',
	},
];

const STACK_HERO_CARDS_DETAILS_2 = [
	{
		title: 'OLTP',
		description:
			'tuned or handling high volumes of short, atomic transactions that ensure data integrity and concurrency in real-time operational systems.',
		image: OLTPStackElephant,
		url: 'https://tembo.io/docs/product/stacks/transactional/oltp',
	},
	{
		title: 'Machine Learning Stack',
		description:
			'Machine learning training and inference directly from Postgres. Built on PostgresML, pg_vector and pg_vectorize.',
		image: MLStackElephant,
		url: 'https://tembo.io/docs/product/stacks/ai/machine-learning',
	},
	{
		title: 'OLAP',
		description:
			'Tuned or handling high volumes of short, atomic transactions that ensure data integrity and concurrency in real-time operational systems.',
		image: OLAPStackElephant,
		url: 'https://tembo.io/docs/product/stacks/analytical/olap',
	},
	{
		title: 'Geospatial',
		description:
			'Postgres indices and operations optimized for Geospatial workloads.',
		image: GeospatialStackElephant,
		url: 'https://tembo.io/docs/product/stacks/analytical/geospatial',
	},
	{
		title: 'Mongo Alternative on Postgres',
		description: 'Mongo-compatible wire protocol on Postgres.',
		image: MongoAlternativeStackElephant,
		url: 'https://tembo.io/docs/product/stacks/transactional/mongo-alternative',
	},
];

const getRotationStyles = (index: number, totalLength: number) => {
	switch (index) {
		case 0:
			return '-rotate-12 mt-[60px]';
		case 1:
			return '-rotate-[8deg]';
		case 2:
			return '-mt-[25px]';
		case 3:
			return 'rotate-[8deg]';
		case 4:
			return 'rotate-12 mt-[60px]';
	}
};
---

<div class='absolute left-1/2 transform -translate-x-1/2 z-20'>
	<div
		id='first-stacks'
		class='flex flex-row gap-12 py-12 transition-opacity duration-700 ease-in-out'
	>
		{
			STACK_HERO_CARDS_DETAILS_1.map((stackCard, index) => {
				return (
					<a
						class={styles(
							'w-[300px] h-[350px] border bg-mwasi border-[#FFFFFF0D] rounded-[30px] px-4 pt-4 pb-6 flex flex-col gap-8 z-10 hover:scale-[101.5%] transition-all duration-300 ease-in-out',
							getRotationStyles(
								index,
								STACK_HERO_CARDS_DETAILS_1.length,
							),
						)}
						href={stackCard.url}
						target='_blank'
						rel='noreferrer'
						data-stack={index}
					>
						<div class='w-[270px] rounded-[28.65px] border-[0.72px] border-[#FFFFFF0D] p-3'>
							<div class='border-dashed border-[#FFFFFF0D] border rounded-[28.65px] relative'>
								<Image
									src={DashedRectangle}
									alt={'dashed rectangle'}
									class='w-full h-full'
								/>
								<Image
									src={CartesianGrid}
									alt={'cartesian grid'}
									class='w-full h-full absolute m-auto text-center left-0 right-0 top-0'
								/>
								<Image
									src={stackCard.image}
									alt={'rag stack elephant'}
									class='absolute m-auto text-center left-0 right-0 top-6'
								/>
							</div>
						</div>
						<div class='flex flex-col gap-2'>
							<h3 class='font-bold text-base leading-[17.19px] text-white'>
								{stackCard.title}
							</h3>
							<p class='font-normal text-xs leading-[14.52px] font-["Inter"] text-otherGrey'>
								{stackCard.description}
							</p>
						</div>
					</a>
				);
			})
		}
	</div>
	<div
		id='second-stacks'
		class='flex flex-row gap-12 fade-x-md py-12 transition-opacity duration-700 ease-in-out opacity-0'
	>
		{
			STACK_HERO_CARDS_DETAILS_2.map((stackCard, index) => {
				return (
					<a
						class={styles(
							'w-[300px] h-[350px] border bg-mwasi border-[#FFFFFF0D] rounded-[30px] px-4 pt-4 pb-6 flex flex-col gap-8 z-10 hover:scale-[101.5%] transition-all duration-300 ease-in-out',
							getRotationStyles(
								index,
								STACK_HERO_CARDS_DETAILS_1.length,
							),
						)}
						href={stackCard.url}
						target='_blank'
						rel='noreferrer'
						data-stack={index}
					>
						<div class='w-[270px] rounded-[28.65px] border-[0.72px] border-[#FFFFFF0D] p-3'>
							<div class='border-dashed border-[#FFFFFF0D] border rounded-[28.65px] relative'>
								<Image
									src={DashedRectangle}
									alt={'dashed rectangle'}
									class='w-full h-full'
								/>
								<Image
									src={CartesianGrid}
									alt={'cartesian grid'}
									class='w-full h-full absolute m-auto text-center left-0 right-0 top-0'
								/>
								<Image
									src={stackCard.image}
									alt={'stack elephant'}
									class='absolute m-auto text-center left-0 right-0 top-6'
								/>
							</div>
						</div>
						<div class='flex flex-col gap-2'>
							<h3 class='font-bold text-base leading-[17.19px] text-white'>
								{stackCard.title}
							</h3>
							<p class='font-normal text-xs leading-[14.52px] font-["Inter"] text-otherGrey'>
								{stackCard.description}
							</p>
						</div>
					</a>
				);
			})
		}
	</div>
</div>

<script>
	const firstDiv = document.getElementById('first-stacks');
	const secondDiv = document.getElementById('second-stacks');
	const displayTime = 5000;
	const transitionTime = 300;

	function getShouldToggle() {
		let shouldToggle = true;
		const stackCardElements = [
			document.getElementById('first-stacks'),
			document.getElementById('second-stacks'),
		];
		stackCardElements.forEach((element) => {
			if (element?.matches(':hover')) {
				shouldToggle = false;
			}
		});
		return shouldToggle;
	}

	function toggleDivs(currentDiv: any, nextDiv: any) {
		if (getShouldToggle()) {
			currentDiv.classList.add('opacity-0');
			setTimeout(() => {
				currentDiv.classList.add('hidden');
				nextDiv.classList.remove('hidden');
				setTimeout(() => {
					nextDiv.classList.remove('opacity-0');
				}, 10);
			}, transitionTime);
		}
	}

	function cycle() {
		if (getShouldToggle()) {
			toggleDivs(firstDiv, secondDiv);
			setTimeout(() => {
				toggleDivs(secondDiv, firstDiv);
			}, displayTime + transitionTime);
		}
	}

	setInterval(cycle, (displayTime + transitionTime) * 2);
</script>
