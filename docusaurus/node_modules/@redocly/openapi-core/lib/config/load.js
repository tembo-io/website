"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConfig = exports.getConfig = exports.findConfig = exports.CONFIG_FILE_NAMES = exports.loadConfig = void 0;
const fs = require("fs");
const path = require("path");
const redocly_1 = require("../redocly");
const utils_1 = require("../utils");
const js_yaml_1 = require("../js-yaml");
const config_1 = require("./config");
const utils_2 = require("./utils");
const config_resolvers_1 = require("./config-resolvers");
function addConfigMetadata({ rawConfig, customExtends, configPath, tokens, files, region, }) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (customExtends !== undefined) {
            rawConfig.styleguide = rawConfig.styleguide || {};
            rawConfig.styleguide.extends = customExtends;
        }
        else if (utils_1.isEmptyObject(rawConfig)) {
            rawConfig.styleguide = { extends: ['recommended'], recommendedFallback: true };
        }
        if (tokens === null || tokens === void 0 ? void 0 : tokens.length) {
            if (!rawConfig.resolve)
                rawConfig.resolve = {};
            if (!rawConfig.resolve.http)
                rawConfig.resolve.http = {};
            rawConfig.resolve.http.headers = [...((_a = rawConfig.resolve.http.headers) !== null && _a !== void 0 ? _a : [])];
            for (const item of tokens) {
                const domain = config_1.DOMAINS[item.region];
                rawConfig.resolve.http.headers.push({
                    matches: `https://api.${domain}/registry/**`,
                    name: 'Authorization',
                    envVariable: undefined,
                    value: item.token,
                }, 
                //support redocly.com domain for future compatibility
                ...(item.region === 'us'
                    ? [
                        {
                            matches: `https://api.redoc.ly/registry/**`,
                            name: 'Authorization',
                            envVariable: undefined,
                            value: item.token,
                        },
                    ]
                    : []));
            }
        }
        return config_resolvers_1.resolveConfig(Object.assign(Object.assign({}, rawConfig), { files: files !== null && files !== void 0 ? files : rawConfig.files, region: region !== null && region !== void 0 ? region : rawConfig.region }), configPath);
    });
}
function loadConfig(options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { configPath = findConfig(), customExtends, processRawConfig, files, region } = options;
        const rawConfig = yield getConfig(configPath, processRawConfig);
        const redoclyClient = new redocly_1.RedoclyClient();
        const tokens = yield redoclyClient.getTokens();
        return addConfigMetadata({
            rawConfig,
            customExtends,
            configPath,
            tokens,
            files,
            region,
        });
    });
}
exports.loadConfig = loadConfig;
exports.CONFIG_FILE_NAMES = ['redocly.yaml', 'redocly.yml', '.redocly.yaml', '.redocly.yml'];
function findConfig(dir) {
    if (!fs.hasOwnProperty('existsSync'))
        return;
    const existingConfigFiles = exports.CONFIG_FILE_NAMES.map((name) => dir ? path.resolve(dir, name) : name).filter(fs.existsSync);
    if (existingConfigFiles.length > 1) {
        throw new Error(`
      Multiple configuration files are not allowed. 
      Found the following files: ${existingConfigFiles.join(', ')}. 
      Please use 'redocly.yaml' instead.
    `);
    }
    return existingConfigFiles[0];
}
exports.findConfig = findConfig;
function getConfig(configPath = findConfig(), processRawConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!configPath || !utils_1.doesYamlFileExist(configPath))
            return {};
        try {
            const rawConfig = (yield utils_1.loadYaml(configPath)) || {};
            if (typeof processRawConfig === 'function') {
                yield processRawConfig(rawConfig);
            }
            return utils_2.transformConfig(rawConfig);
        }
        catch (e) {
            throw new Error(`Error parsing config file at '${configPath}': ${e.message}`);
        }
    });
}
exports.getConfig = getConfig;
function createConfig(config, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return addConfigMetadata(Object.assign({ rawConfig: utils_2.transformConfig(typeof config === 'string' ? js_yaml_1.parseYaml(config) : config) }, options));
    });
}
exports.createConfig = createConfig;
