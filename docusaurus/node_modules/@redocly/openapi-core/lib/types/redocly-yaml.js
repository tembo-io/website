"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigTypes = void 0;
const _1 = require(".");
const utils_1 = require("../utils");
const builtInRulesList = [
    'spec',
    'info-contact',
    'info-license',
    'info-license-url',
    'operation-2xx-response',
    'operation-4xx-response',
    'operation-4xx-problem-details-rfc7807',
    'assertions',
    'operation-operationId-unique',
    'operation-parameters-unique',
    'path-parameters-defined',
    'operation-tag-defined',
    'no-example-value-and-externalValue',
    'no-enum-type-mismatch',
    'no-path-trailing-slash',
    'no-empty-servers',
    'path-declaration-must-exist',
    'operation-operationId-url-safe',
    'operation-operationId',
    'operation-summary',
    'tags-alphabetical',
    'no-server-example.com',
    'no-server-trailing-slash',
    'tag-description',
    'operation-description',
    'no-unused-components',
    'path-not-include-query',
    'path-params-defined',
    'parameter-description',
    'operation-singular-tag',
    'security-defined',
    'no-unresolved-refs',
    'paths-kebab-case',
    'boolean-parameter-prefixes',
    'path-http-verbs-order',
    'no-invalid-media-type-examples',
    'no-identical-paths',
    'no-ambiguous-paths',
    'no-undefined-server-variable',
    'no-server-variables-empty-enum',
    'no-http-verbs-in-paths',
    'path-excludes-patterns',
    'request-mime-type',
    'response-mime-type',
    'path-segment-plural',
    'no-invalid-schema-examples',
    'no-invalid-parameter-examples',
    'response-contains-header',
    'response-contains-property',
    'scalar-property-missing-example',
    'spec-components-invalid-map-name',
];
const nodeTypesList = [
    'any',
    'Root',
    'Tag',
    'TagList',
    'ExternalDocs',
    'Server',
    'ServerList',
    'ServerVariable',
    'ServerVariablesMap',
    'SecurityRequirement',
    'SecurityRequirementList',
    'Info',
    'Contact',
    'License',
    'Paths',
    'PathItem',
    'Parameter',
    'ParameterList',
    'Operation',
    'Callback',
    'CallbacksMap',
    'RequestBody',
    'MediaTypesMap',
    'MediaType',
    'Example',
    'ExamplesMap',
    'Encoding',
    'EncodingMap',
    'Header',
    'HeadersMap',
    'Responses',
    'Response',
    'Link',
    'LinksMap',
    'Schema',
    'Xml',
    'SchemaProperties',
    'DiscriminatorMapping',
    'Discriminator',
    'Components',
    'NamedSchemas',
    'NamedResponses',
    'NamedParameters',
    'NamedExamples',
    'NamedRequestBodies',
    'NamedHeaders',
    'NamedSecuritySchemes',
    'NamedLinks',
    'NamedCallbacks',
    'ImplicitFlow',
    'PasswordFlow',
    'ClientCredentials',
    'AuthorizationCode',
    'OAuth2Flows',
    'SecurityScheme',
    'XCodeSample',
    'XCodeSampleList',
    'WebhooksMap',
    'SpecExtension',
];
const ConfigStyleguide = {
    properties: {
        extends: {
            type: 'array',
            items: {
                type: 'string',
            },
        },
        rules: 'Rules',
        oas2Rules: 'Rules',
        oas3_0Rules: 'Rules',
        oas3_1Rules: 'Rules',
        preprocessors: { type: 'object' },
        oas2Preprocessors: { type: 'object' },
        oas3_0Preprocessors: { type: 'object' },
        oas3_1Preprocessors: { type: 'object' },
        decorators: { type: 'object' },
        oas2Decorators: { type: 'object' },
        oas3_0Decorators: { type: 'object' },
        oas3_1Decorators: { type: 'object' },
    },
};
const RootConfigStyleguide = {
    properties: Object.assign({ plugins: {
            type: 'array',
            items: { type: 'string' },
        } }, ConfigStyleguide.properties),
};
const ConfigRoot = {
    properties: Object.assign(Object.assign({ organization: { type: 'string' }, apis: 'ConfigApis' }, RootConfigStyleguide.properties), { theme: 'ConfigRootTheme', 'features.openapi': 'ConfigReferenceDocs', 'features.mockServer': 'ConfigMockServer', region: { enum: ['us', 'eu'] }, resolve: {
            properties: {
                http: 'ConfigHTTP',
                doNotResolveExamples: { type: 'boolean' },
            },
        }, files: {
            type: 'array',
            items: {
                type: 'string',
            },
        } }),
};
const ConfigApis = {
    properties: {},
    additionalProperties: 'ConfigApisProperties',
};
const ConfigApisProperties = {
    properties: Object.assign(Object.assign({ root: { type: 'string' }, labels: {
            type: 'array',
            items: {
                type: 'string',
            },
        }, lint: 'ConfigStyleguide', styleguide: 'ConfigStyleguide' }, ConfigStyleguide.properties), { 'features.openapi': 'ConfigReferenceDocs', 'features.mockServer': 'ConfigMockServer', theme: 'ConfigRootTheme', files: {
            type: 'array',
            items: {
                type: 'string',
            },
        } }),
    required: ['root'],
};
const ConfigHTTP = {
    properties: {
        headers: {
            type: 'array',
            items: {
                type: 'string',
            },
        },
    },
};
const ConfigRootTheme = {
    properties: {
        openapi: 'ConfigReferenceDocs',
        mockServer: 'ConfigMockServer',
    },
};
const Rules = {
    properties: {},
    additionalProperties: (value, key) => {
        if (key.startsWith('assert/')) {
            return 'Assert';
        }
        else if (builtInRulesList.includes(key) || utils_1.isCustomRuleId(key)) {
            if (typeof value === 'string') {
                return { enum: ['error', 'warn', 'off'] };
            }
            else {
                return 'ObjectRule';
            }
        }
        // Otherwise is considered as invalid
        return;
    },
};
const ObjectRule = {
    properties: {
        severity: { enum: ['error', 'warn', 'off'] },
    },
    additionalProperties: {},
    required: ['severity'],
};
const AssertionDefinitionSubject = {
    properties: {
        type: { enum: nodeTypesList },
        property: (value) => {
            if (Array.isArray(value)) {
                return { type: 'array', items: { type: 'string' } };
            }
            else if (value === null) {
                return null;
            }
            else {
                return { type: 'string' };
            }
        },
        filterInParentKeys: { type: 'array', items: { type: 'string' } },
        filterOutParentKeys: { type: 'array', items: { type: 'string' } },
        matchParentKeys: { type: 'string' },
    },
    required: ['type'],
};
const AssertionDefinitionAssertions = {
    properties: {
        enum: { type: 'array', items: { type: 'string' } },
        pattern: { type: 'string' },
        notPattern: { type: 'string' },
        casing: {
            enum: [
                'camelCase',
                'kebab-case',
                'snake_case',
                'PascalCase',
                'MACRO_CASE',
                'COBOL-CASE',
                'flatcase',
            ],
        },
        mutuallyExclusive: { type: 'array', items: { type: 'string' } },
        mutuallyRequired: { type: 'array', items: { type: 'string' } },
        required: { type: 'array', items: { type: 'string' } },
        requireAny: { type: 'array', items: { type: 'string' } },
        disallowed: { type: 'array', items: { type: 'string' } },
        defined: { type: 'boolean' },
        // undefined: { type: 'boolean' }, // TODO: Remove `undefined` assertion from codebase overall
        nonEmpty: { type: 'boolean' },
        minLength: { type: 'integer' },
        maxLength: { type: 'integer' },
        ref: (value) => typeof value === 'string' ? { type: 'string' } : { type: 'boolean' },
        const: (value) => {
            if (typeof value === 'string') {
                return { type: 'string' };
            }
            if (typeof value === 'number') {
                return { type: 'number' };
            }
            if (typeof value === 'boolean') {
                return { type: 'boolean' };
            }
            else {
                return;
            }
        },
    },
    additionalProperties: (_value, key) => {
        if (/^\w+\/\w+$/.test(key))
            return { type: 'object' };
        return;
    },
};
const AssertDefinition = {
    properties: {
        subject: 'AssertionDefinitionSubject',
        assertions: 'AssertionDefinitionAssertions',
    },
    required: ['subject', 'assertions'],
};
const Assert = {
    properties: {
        subject: 'AssertionDefinitionSubject',
        assertions: 'AssertionDefinitionAssertions',
        where: _1.listOf('AssertDefinition'),
        message: { type: 'string' },
        suggest: { type: 'array', items: { type: 'string' } },
        severity: { enum: ['error', 'warn', 'off'] },
    },
    required: ['subject', 'assertions'],
};
const ConfigLanguage = {
    properties: {
        label: { type: 'string' },
        lang: {
            enum: [
                'curl',
                'C#',
                'Go',
                'Java',
                'Java8+Apache',
                'JavaScript',
                'Node.js',
                'PHP',
                'Python',
                'R',
                'Ruby',
            ],
        },
    },
    required: ['lang'],
};
const ConfigLabels = {
    properties: {
        enum: { type: 'string' },
        enumSingleValue: { type: 'string' },
        enumArray: { type: 'string' },
        default: { type: 'string' },
        deprecated: { type: 'string' },
        example: { type: 'string' },
        examples: { type: 'string' },
        nullable: { type: 'string' },
        recursive: { type: 'string' },
        arrayOf: { type: 'string' },
        webhook: { type: 'string' },
        authorizations: { type: 'string' },
        tryItAuthBasicUsername: { type: 'string' },
        tryItAuthBasicPassword: { type: 'string' },
    },
};
const ConfigSidebarLinks = {
    properties: {
        beforeInfo: _1.listOf('CommonConfigSidebarLinks'),
        end: _1.listOf('CommonConfigSidebarLinks'),
    },
};
const CommonConfigSidebarLinks = {
    properties: {
        label: { type: 'string' },
        link: { type: 'string' },
        target: { type: 'string' },
    },
    required: ['label', 'link'],
};
const CommonThemeColors = {
    properties: {
        main: { type: 'string' },
        light: { type: 'string' },
        dark: { type: 'string' },
        contrastText: { type: 'string' },
    },
};
const CommonColorProps = {
    properties: {
        backgroundColor: { type: 'string' },
        borderColor: { type: 'string' },
        color: { type: 'string' },
        tabTextColor: { type: 'string' },
    },
};
const BorderThemeColors = {
    properties: utils_1.pickObjectProps(CommonThemeColors.properties, ['light', 'dark']),
};
const HttpColors = {
    properties: {
        basic: { type: 'string' },
        delete: { type: 'string' },
        get: { type: 'string' },
        head: { type: 'string' },
        link: { type: 'string' },
        options: { type: 'string' },
        patch: { type: 'string' },
        post: { type: 'string' },
        put: { type: 'string' },
    },
};
const ResponseColors = {
    properties: {
        error: 'CommonColorProps',
        info: 'CommonColorProps',
        redirect: 'CommonColorProps',
        success: 'CommonColorProps',
    },
};
const SecondaryColors = {
    properties: utils_1.omitObjectProps(CommonThemeColors.properties, ['dark']),
};
const TextThemeColors = {
    properties: {
        primary: { type: 'string' },
        secondary: { type: 'string' },
        light: { type: 'string' },
    },
};
const ThemeColors = {
    properties: {
        accent: 'CommonThemeColors',
        border: 'BorderThemeColors',
        error: 'CommonThemeColors',
        http: 'HttpColors',
        primary: 'CommonThemeColors',
        responses: 'ResponseColors',
        secondary: 'SecondaryColors',
        success: 'CommonThemeColors',
        text: 'TextThemeColors',
        tonalOffset: { type: 'number' },
        warning: 'CommonThemeColors',
    },
};
const SizeProps = {
    properties: {
        fontSize: { type: 'string' },
        padding: { type: 'string' },
        minWidth: { type: 'string' },
    },
};
const Sizes = {
    properties: {
        small: 'SizeProps',
        medium: 'SizeProps',
        large: 'SizeProps',
        xlarge: 'SizeProps',
    },
};
const FontConfig = {
    properties: {
        fontFamily: { type: 'string' },
        fontSize: { type: 'string' },
        fontWeight: { type: 'string' },
        lineHeight: { type: 'string' },
    },
};
const ButtonsConfig = {
    properties: Object.assign(Object.assign({}, utils_1.omitObjectProps(FontConfig.properties, ['fontSize', 'lineHeight'])), { borderRadius: { type: 'string' }, hoverStyle: { type: 'string' }, boxShadow: { type: 'string' }, hoverBoxShadow: { type: 'string' }, sizes: 'Sizes' }),
};
const BadgeFontConfig = {
    properties: utils_1.pickObjectProps(FontConfig.properties, ['fontSize', 'lineHeight']),
};
const BadgeSizes = {
    properties: {
        medium: 'BadgeFontConfig',
        small: 'BadgeFontConfig',
    },
};
const HttpBadgesConfig = {
    properties: Object.assign(Object.assign({}, utils_1.omitObjectProps(FontConfig.properties, ['fontSize', 'lineHeight'])), { borderRadius: { type: 'string' }, color: { type: 'string' }, sizes: 'BadgeSizes' }),
};
const LabelControls = {
    properties: {
        top: { type: 'string' },
        width: { type: 'string' },
        height: { type: 'string' },
    },
};
const Panels = {
    properties: {
        borderRadius: { type: 'string' },
        backgroundColor: { type: 'string' },
    },
};
const TryItButton = {
    properties: {
        fullWidth: { type: 'boolean' },
    },
};
const Components = {
    properties: {
        buttons: 'ButtonsConfig',
        httpBadges: 'HttpBadgesConfig',
        layoutControls: 'LabelControls',
        panels: 'Panels',
        tryItButton: 'TryItButton',
        tryItSendButton: 'TryItButton',
    },
};
const Breakpoints = {
    properties: {
        small: { type: 'string' },
        medium: { type: 'string' },
        large: { type: 'string' },
    },
};
const StackedConfig = {
    properties: {
        maxWidth: 'Breakpoints',
    },
};
const ThreePanelConfig = {
    properties: {
        maxWidth: 'Breakpoints',
        middlePanelMaxWidth: 'Breakpoints',
    },
};
const Layout = {
    properties: {
        showDarkRightPanel: { type: 'boolean' },
        stacked: 'StackedConfig',
        'three-panel': 'ThreePanelConfig',
    },
};
const SchemaColorsConfig = {
    properties: {
        backgroundColor: { type: 'string' },
        border: { type: 'string' },
    },
};
const Schema = {
    properties: {
        breakFieldNames: { type: 'boolean' },
        caretColor: { type: 'string' },
        caretSize: { type: 'string' },
        constraints: 'SchemaColorsConfig',
        defaultDetailsWidth: { type: 'string' },
        examples: 'SchemaColorsConfig',
        labelsTextSize: { type: 'string' },
        linesColor: { type: 'string' },
        nestedBackground: { type: 'string' },
        nestingSpacing: { type: 'string' },
        requireLabelColor: { type: 'string' },
        typeNameColor: { type: 'string' },
        typeTitleColor: { type: 'string' },
    },
};
const GroupItemsConfig = {
    properties: {
        subItemsColor: { type: 'string' },
        textTransform: { type: 'string' },
        fontWeight: { type: 'string' },
    },
};
const Level1Items = {
    properties: utils_1.pickObjectProps(GroupItemsConfig.properties, ['textTransform']),
};
const SpacingConfig = {
    properties: {
        unit: { type: 'number' },
        paddingHorizontal: { type: 'string' },
        paddingVertical: { type: 'string' },
        offsetTop: { type: 'string' },
        offsetLeft: { type: 'string' },
        offsetNesting: { type: 'string' },
    },
};
const Sidebar = {
    properties: Object.assign(Object.assign({}, utils_1.omitObjectProps(FontConfig.properties, ['fontWeight', 'lineHeight'])), { activeBgColor: { type: 'string' }, activeTextColor: { type: 'string' }, backgroundColor: { type: 'string' }, borderRadius: { type: 'string' }, breakPath: { type: 'boolean' }, caretColor: { type: 'string' }, caretSize: { type: 'string' }, groupItems: 'GroupItemsConfig', level1items: 'Level1Items', rightLineColor: { type: 'string' }, separatorLabelColor: { type: 'string' }, showAtBreakpoint: { type: 'string' }, spacing: 'SpacingConfig', textColor: { type: 'string' }, width: { type: 'string' } }),
};
const Heading = {
    properties: Object.assign(Object.assign({}, FontConfig.properties), { color: { type: 'string' }, transform: { type: 'string' } }),
};
const CodeConfig = {
    properties: Object.assign(Object.assign({}, FontConfig.properties), { backgroundColor: { type: 'string' }, color: { type: 'string' }, wordBreak: {
            enum: [
                'break-all',
                'break-word',
                'keep-all',
                'normal',
                'revert',
                'unset',
                'inherit',
                'initial',
            ],
        }, wrap: { type: 'boolean' } }),
};
const HeadingsConfig = {
    properties: utils_1.omitObjectProps(FontConfig.properties, ['fontSize']),
};
const LinksConfig = {
    properties: {
        color: { type: 'string' },
        hover: { type: 'string' },
        textDecoration: { type: 'string' },
        hoverTextDecoration: { type: 'string' },
        visited: { type: 'string' },
    },
};
const Typography = {
    properties: Object.assign(Object.assign({ code: 'CodeConfig', fieldName: 'FontConfig' }, utils_1.pickObjectProps(FontConfig.properties, ['fontSize', 'fontFamily'])), { fontWeightBold: { type: 'string' }, fontWeightLight: { type: 'string' }, fontWeightRegular: { type: 'string' }, heading1: 'Heading', heading2: 'Heading', heading3: 'Heading', headings: 'HeadingsConfig', lineHeight: { type: 'string' }, links: 'LinksConfig', optimizeSpeed: { type: 'boolean' }, rightPanelHeading: 'Heading', smoothing: { enum: ['auto', 'none', 'antialiased', 'subpixel-antialiased', 'grayscale'] } }),
};
const TokenProps = {
    properties: Object.assign({ color: { type: 'string' } }, utils_1.omitObjectProps(FontConfig.properties, ['fontWeight'])),
};
const CodeBlock = {
    properties: {
        backgroundColor: { type: 'string' },
        borderRadius: { type: 'string' },
        tokens: 'TokenProps',
    },
};
const Logo = {
    properties: {
        gutter: { type: 'string' },
        maxHeight: { type: 'string' },
        maxWidth: { type: 'string' },
    },
};
const Fab = {
    properties: {
        backgroundColor: { type: 'string' },
        color: { type: 'string' },
    },
};
const ButtonOverrides = {
    properties: {
        custom: { type: 'string' },
    },
};
const Overrides = {
    properties: {
        DownloadButton: 'ButtonOverrides',
        NextSectionButton: 'ButtonOverrides',
    },
};
const RightPanel = {
    properties: {
        backgroundColor: { type: 'string' },
        panelBackgroundColor: { type: 'string' },
        panelControlsBackgroundColor: { type: 'string' },
        showAtBreakpoint: { type: 'string' },
        textColor: { type: 'string' },
        width: { type: 'string' },
    },
};
const Shape = {
    properties: { borderRadius: { type: 'string' } },
};
const ThemeSpacing = {
    properties: {
        sectionHorizontal: { type: 'number' },
        sectionVertical: { type: 'number' },
        unit: { type: 'number' },
    },
};
const ConfigTheme = {
    properties: {
        breakpoints: 'Breakpoints',
        codeBlock: 'CodeBlock',
        colors: 'ThemeColors',
        components: 'Components',
        layout: 'Layout',
        logo: 'Logo',
        fab: 'Fab',
        overrides: 'Overrides',
        rightPanel: 'RightPanel',
        schema: 'Schema',
        shape: 'Shape',
        sidebar: 'Sidebar',
        spacing: 'ThemeSpacing',
        typography: 'Typography',
        links: { properties: { color: { type: 'string' } } },
        codeSample: { properties: { backgroundColor: { type: 'string' } } }, // deprecated
    },
};
const GenerateCodeSamples = {
    properties: {
        skipOptionalParameters: { type: 'boolean' },
        languages: _1.listOf('ConfigLanguage'),
    },
    required: ['languages'],
};
const ConfigReferenceDocs = {
    properties: {
        theme: 'ConfigTheme',
        corsProxyUrl: { type: 'string' },
        ctrlFHijack: { type: 'boolean' },
        defaultSampleLanguage: { type: 'string' },
        disableDeepLinks: { type: 'boolean' },
        disableSearch: { type: 'boolean' },
        disableSidebar: { type: 'boolean' },
        downloadDefinitionUrl: { type: 'string' },
        expandDefaultServerVariables: { type: 'boolean' },
        enumSkipQuotes: { type: 'boolean' },
        expandDefaultRequest: { type: 'boolean' },
        expandDefaultResponse: { type: 'boolean' },
        expandResponses: { type: 'string' },
        expandSingleSchemaField: { type: 'boolean' },
        generateCodeSamples: 'GenerateCodeSamples',
        generatedPayloadSamplesMaxDepth: { type: 'number' },
        hideDownloadButton: { type: 'boolean' },
        hideHostname: { type: 'boolean' },
        hideInfoSection: { type: 'boolean' },
        hideLoading: { type: 'boolean' },
        hideLogo: { type: 'boolean' },
        hideRequestPayloadSample: { type: 'boolean' },
        hideRightPanel: { type: 'boolean' },
        hideSchemaPattern: { type: 'boolean' },
        hideSchemaTitles: { type: 'boolean' },
        hideSingleRequestSampleTab: { type: 'boolean' },
        hideSecuritySection: { type: 'boolean' },
        hideTryItPanel: { type: 'boolean' },
        hideFab: { type: 'boolean' },
        hideOneOfDescription: { type: 'boolean' },
        htmlTemplate: { type: 'string' },
        jsonSampleExpandLevel: (value) => {
            if (typeof value === 'number') {
                return { type: 'number', minimum: 1 };
            }
            else {
                return { type: 'string' };
            }
        },
        labels: 'ConfigLabels',
        layout: { enum: ['stacked', 'three-panel'] },
        maxDisplayedEnumValues: { type: 'number' },
        menuToggle: { type: 'boolean' },
        nativeScrollbars: { type: 'boolean' },
        noAutoAuth: { type: 'boolean' },
        oAuth2RedirectURI: { type: 'string' },
        onDeepLinkClick: { type: 'object' },
        onlyRequiredInSamples: { type: 'boolean' },
        pagination: { enum: ['none', 'section', 'item'] },
        pathInMiddlePanel: { type: 'boolean' },
        payloadSampleIdx: { type: 'number', minimum: 0 },
        requestInterceptor: { type: 'object' },
        requiredPropsFirst: { type: 'boolean' },
        routingBasePath: { type: 'string' },
        routingStrategy: { type: 'string' },
        samplesTabsMaxCount: { type: 'number' },
        schemaExpansionLevel: (value) => {
            if (typeof value === 'number') {
                return { type: 'number', minimum: 0 };
            }
            else {
                return { type: 'string' };
            }
        },
        schemaDefinitionsTagName: { type: 'string' },
        minCharacterLengthToInitSearch: { type: 'number', minimum: 1 },
        maxResponseHeadersToShowInTryIt: { type: 'number', minimum: 0 },
        scrollYOffset: (value) => {
            if (typeof value === 'number') {
                return { type: 'number' };
            }
            else {
                return { type: 'string' };
            }
        },
        searchAutoExpand: { type: 'boolean' },
        searchFieldLevelBoost: { type: 'number', minimum: 0 },
        searchMaxDepth: { type: 'number', minimum: 1 },
        searchMode: { enum: ['default', 'path-only'] },
        searchOperationTitleBoost: { type: 'number' },
        searchTagTitleBoost: { type: 'number' },
        sendXUserAgentInTryIt: { type: 'boolean' },
        showChangeLayoutButton: { type: 'boolean' },
        showConsole: { type: 'boolean' },
        showExtensions: (value) => {
            if (typeof value === 'boolean') {
                return { type: 'boolean' };
            }
            else {
                return {
                    type: 'array',
                    items: {
                        type: 'string',
                    },
                };
            }
        },
        showNextButton: { type: 'boolean' },
        showRightPanelToggle: { type: 'boolean' },
        showSecuritySchemeType: { type: 'boolean' },
        showWebhookVerb: { type: 'boolean' },
        showObjectSchemaExamples: { type: 'boolean' },
        disableTryItRequestUrlEncoding: { type: 'boolean' },
        sidebarLinks: 'ConfigSidebarLinks',
        sideNavStyle: { enum: ['summary-only', 'path-first', 'id-only'] },
        simpleOneOfTypeLabel: { type: 'boolean' },
        sortEnumValuesAlphabetically: { type: 'boolean' },
        sortOperationsAlphabetically: { type: 'boolean' },
        sortPropsAlphabetically: { type: 'boolean' },
        sortTagsAlphabetically: { type: 'boolean' },
        suppressWarnings: { type: 'boolean' },
        unstable_externalDescription: { type: 'boolean' },
        unstable_ignoreMimeParameters: { type: 'boolean' },
        untrustedDefinition: { type: 'boolean' },
        mockServer: {
            properties: {
                url: { type: 'string' },
                position: { enum: ['first', 'last', 'replace', 'off'] },
                description: { type: 'string' },
            },
        },
        showAccessMode: { type: 'boolean' },
        preserveOriginalExtensionsName: { type: 'boolean' },
        markdownHeadingsAnchorLevel: { type: 'number' },
    },
    additionalProperties: { type: 'string' },
};
const ConfigMockServer = {
    properties: {
        strictExamples: { type: 'boolean' },
        errorIfForcedExampleNotFound: { type: 'boolean' },
    },
};
exports.ConfigTypes = {
    Assert,
    ConfigRoot,
    ConfigApis,
    ConfigApisProperties,
    RootConfigStyleguide,
    ConfigStyleguide,
    ConfigReferenceDocs,
    ConfigMockServer,
    ConfigHTTP,
    ConfigLanguage,
    ConfigLabels,
    ConfigSidebarLinks,
    CommonConfigSidebarLinks,
    ConfigTheme,
    ConfigRootTheme,
    AssertDefinition,
    ThemeColors,
    CommonThemeColors,
    BorderThemeColors,
    HttpColors,
    ResponseColors,
    SecondaryColors,
    TextThemeColors,
    Sizes,
    ButtonsConfig,
    CommonColorProps,
    BadgeFontConfig,
    BadgeSizes,
    HttpBadgesConfig,
    LabelControls,
    Panels,
    TryItButton,
    Breakpoints,
    StackedConfig,
    ThreePanelConfig,
    SchemaColorsConfig,
    SizeProps,
    Level1Items,
    SpacingConfig,
    FontConfig,
    CodeConfig,
    HeadingsConfig,
    LinksConfig,
    TokenProps,
    CodeBlock,
    Logo,
    Fab,
    ButtonOverrides,
    Overrides,
    ObjectRule,
    RightPanel,
    Rules,
    Shape,
    ThemeSpacing,
    GenerateCodeSamples,
    GroupItemsConfig,
    Components,
    Layout,
    Schema,
    Sidebar,
    Heading,
    Typography,
    AssertionDefinitionAssertions,
    AssertionDefinitionSubject,
};
