"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8306],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},g="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),g=p(n),c=i,d=g["".concat(o,".").concat(c)]||g[c]||u[c]||r;return n?a.createElement(d,s(s({ref:t},m),{},{components:n})):a.createElement(d,s({ref:t},m))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=c;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[g]="string"==typeof e?e:i,s[1]=l;for(var p=2;p<r;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},56800:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={slug:"postgres-extension-in-rust-pgmq",title:"Anatomy of a Postgres extension written in Rust: pgmq",authors:["rjzv"],tags:["postgres","pgmq","rust","pgrx","extensions"],image:"./pgmq-archive.png"},s=void 0,l={permalink:"/blog/postgres-extension-in-rust-pgmq",editUrl:"https://github.com/tembo-io/website/blob/main/blog/2023-09-28-pgmq-internals/index.md",source:"@site/blog/2023-09-28-pgmq-internals/index.md",title:"Anatomy of a Postgres extension written in Rust: pgmq",description:"In my previous submission to this space, I described my experience with pgmq while using the Python library. In this post, I'll share what I found after inspecting the code.",date:"2023-09-28T00:00:00.000Z",formattedDate:"September 28, 2023",tags:[{label:"postgres",permalink:"/blog/tags/postgres"},{label:"pgmq",permalink:"/blog/tags/pgmq"},{label:"rust",permalink:"/blog/tags/rust"},{label:"pgrx",permalink:"/blog/tags/pgrx"},{label:"extensions",permalink:"/blog/tags/extensions"}],readingTime:11.11,hasTruncateMarker:!1,authors:[{name:"Binidxaba",title:"Community contributor",url:"https://github.com/binidxaba",email:"noreply@tembo.io",imageURL:"https://github.com/binidxaba.png",key:"rjzv"}],frontMatter:{slug:"postgres-extension-in-rust-pgmq",title:"Anatomy of a Postgres extension written in Rust: pgmq",authors:["rjzv"],tags:["postgres","pgmq","rust","pgrx","extensions"],image:"./pgmq-archive.png"},prevItem:{title:"Version History and Lifecycle Policies for Postgres Tables",permalink:"/blog/table-version-history"},nextItem:{title:"Postgres 16: The exciting and the unnoticed",permalink:"/blog/postgres-16"}},o={image:n(3057).Z,authorsImageUrls:[void 0]},p=[{value:"Project structure",id:"project-structure",level:2},{value:"Installing the pgmq extension",id:"installing-the-pgmq-extension",level:2},{value:"The internals",id:"the-internals",level:2},{value:"pgmq.create()",id:"pgmqcreate",level:3},{value:"pgmq.send()",id:"pgmqsend",level:3},{value:"pgmq.read()",id:"pgmqread",level:3},{value:"pgmq.archive()",id:"pgmqarchive",level:3},{value:"pgmq.drop_queue()",id:"pgmqdrop_queue",level:3},{value:"Conclusion",id:"conclusion",level:2}],m={toc:p},g="wrapper";function u(e){let{components:t,...r}=e;return(0,i.kt)(g,(0,a.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In my ",(0,i.kt)("a",{parentName:"p",href:"https://tembo.io/blog/pgmq-with-python"},"previous submission")," to this space, I described my experience with ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tembo-io/pgmq"},"pgmq")," while using the Python library. In this post, I'll share what I found after inspecting the code."),(0,i.kt)("p",null,"So, first, I'll describe the general structure of the project. Then, I'll explain what happens when we install the pgmq extension. Finally, I'll describe how some of its functions work."),(0,i.kt)("p",null,"In this post, I'll be using version v0.25.0, which you can find ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tembo-io/pgmq/releases/tag/v0.25.0"},"here"),"."),(0,i.kt)("h2",{id:"project-structure"},"Project structure"),(0,i.kt)("p",null,"After cloning the appropriate tag, we can see that the repository contains the following files:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ ls -1\nCargo.lock\nCargo.toml\nCONTRIBUTING.md\ncore\nDockerfile.build\nexamples\nimages\nLICENSE\nMakefile\npgmq.control\npgmq-rs\nREADME.md\nsql\nsrc\ntembo-pgmq-python\ntests\n")),(0,i.kt)("p",null,"The project uses ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/pgcentralfoundation/pgrx"},"pgrx"),". From pgrx's ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/pgcentralfoundation/pgrx/blob/develop/README.md"},"README"),", we know that the relevant files for the extension are ",(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"pgmq.control")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"src")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"sql")," directories:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ tree sql src\nsql\n\u251c\u2500\u2500 pgmq--0.10.2--0.11.1.sql\n\u251c\u2500\u2500 pgmq--0.11.1--0.11.2.sql\n...\n\u251c\u2500\u2500 pgmq--0.8.0--0.8.1.sql\n\u251c\u2500\u2500 pgmq--0.8.1--0.9.0.sql\n\u2514\u2500\u2500 pgmq--0.9.0--0.10.2.sql\nsrc\n\u251c\u2500\u2500 api.rs\n\u251c\u2500\u2500 errors.rs\n\u251c\u2500\u2500 lib.rs\n\u251c\u2500\u2500 metrics.rs\n\u251c\u2500\u2500 partition.rs\n\u251c\u2500\u2500 sql_src.sql\n\u2514\u2500\u2500 util.rs\n\n0 directories, 7 files\n")),(0,i.kt)("h2",{id:"installing-the-pgmq-extension"},"Installing the pgmq extension"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This section assumes that you have successfully installed the pre-requisites as described in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tembo-io/pgmq/blob/main/CONTRIBUTING.md"},"CONTRIBUTING.md"))),(0,i.kt)("p",null,"To build the pgmq extension, we can do the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cargo build\n")),(0,i.kt)("p",null,"Alternatively, to build and install the pgmq extension, we can do:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cargo pgrx install\n")),(0,i.kt)("p",null,"In either case, we can see a shared library ",(0,i.kt)("inlineCode",{parentName:"p"},"pgmq.so")," being created. The installation process also places the shared library in the ",(0,i.kt)("inlineCode",{parentName:"p"},"lib")," directory of the postgres installation; and the sql files and the control file in the ",(0,i.kt)("inlineCode",{parentName:"p"},"extensions")," directory. In my case:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ ls -1 /opt/postgres/share/extension/pgmq*\n/opt/postgres/share/extension/pgmq--0.10.2--0.11.1.sql\n...\n/opt/postgres/share/extension/pgmq--0.9.0--0.10.2.sql\n/opt/postgres/share/extension/pgmq.control\n\n$ ls -1 /opt/postgres/lib/pgmq*\n/opt/postgres/lib/pgmq.so\n")),(0,i.kt)("p",null,"To test the extension, we can do:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cargo pgrx run\n")),(0,i.kt)("p",null,"and it'll start a ",(0,i.kt)("inlineCode",{parentName:"p"},"psql")," prompt. In the prompt, we can execute the ",(0,i.kt)("inlineCode",{parentName:"p"},"create extension")," statement to start using pgmq:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"-- List installed extensions\n\\dx\n\n-- Enable pgmq\ncreate extension pgmq;\n\n-- List installed extensions again\n\\dx\n")),(0,i.kt)("p",null,"The output will look something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"pgmq=# \\dx\n                 List of installed extensions\n  Name   | Version |   Schema   |         Description\n---------+---------+------------+------------------------------\n plpgsql | 1.0     | pg_catalog | PL/pgSQL procedural language\n(1 row)\n\npgmq=# create extension pgmq;\nCREATE EXTENSION\n\npgmq=# \\dx\n                                     List of installed extensions\n  Name   | Version |   Schema   |                             Description\n---------+---------+------------+---------------------------------------------------------------------\n pgmq    | 0.25.0  | public     | A lightweight message queue. Like AWS SQS and RSMQ but on Postgres.\n plpgsql | 1.0     | pg_catalog | PL/pgSQL procedural language\n(2 rows)\n")),(0,i.kt)("p",null,"We can also list the available functions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"-- List available functions under pgmq schema\n\\df pgmq.*\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"pgmq=# \\df pgmq.*\n                                                                         List of functions\n Schema |          Name          |                                                                         Result data type                                                                         |                                                 Argument data types                                                  | Type \n--------+------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------+------\n pgmq   | archive                | boolean                                                                                                                                                          | queue_name text, msg_id bigint                                                                                       | func\n pgmq   | archive                | TABLE(archive boolean)                                                                                                                                           | queue_name text, msg_ids bigint[]                                                                                    | func\n pgmq   | create                 | void                                                                                                                                                             | queue_name text                                                                                                      | func\n pgmq   | create_non_partitioned | void                                                                                                                                                             | queue_name text                                                                                                      | func\n pgmq   | create_partitioned     | void                                                                                                                                                             | queue_name text, partition_interval text DEFAULT '10000'::text, retention_interval text DEFAULT '100000'::text       | func\n pgmq   | delete                 | boolean                                                                                                                                                          | queue_name text, msg_id bigint                                                                                       | func\n pgmq   | delete                 | TABLE(delete boolean)                                                                                                                                            | queue_name text, msg_ids bigint[]                                                                                    | func\n pgmq   | drop_queue             | boolean                                                                                                                                                          | queue_name text, partitioned boolean DEFAULT false                                                                   | func\n pgmq   | list_queues            | TABLE(queue_name text, created_at timestamp with time zone)                                                                                                      |                                                                                                                      | func\n pgmq   | metrics                | TABLE(queue_name text, queue_length bigint, newest_msg_age_sec integer, oldest_msg_age_sec integer, total_messages bigint, scrape_time timestamp with time zone) | queue_name text                                                                                                      | func\n pgmq   | metrics_all            | TABLE(queue_name text, queue_length bigint, newest_msg_age_sec integer, oldest_msg_age_sec integer, total_messages bigint, scrape_time timestamp with time zone) |                                                                                                                      | func\n pgmq   | pop                    | TABLE(msg_id bigint, read_ct integer, enqueued_at timestamp with time zone, vt timestamp with time zone, message jsonb)                                          | queue_name text                                                                                                      | func\n pgmq   | purge_queue            | bigint                                                                                                                                                           | queue_name text                                                                                                      | func\n pgmq   | read                   | TABLE(msg_id bigint, read_ct integer, enqueued_at timestamp with time zone, vt timestamp with time zone, message jsonb)                                          | queue_name text, vt integer, \"limit\" integer                                                                         | func\n pgmq   | read_with_poll         | TABLE(msg_id bigint, read_ct integer, enqueued_at timestamp with time zone, vt timestamp with time zone, message jsonb)                                          | queue_name text, vt integer, \"limit\" integer, poll_timeout_s integer DEFAULT 5, poll_interval_ms integer DEFAULT 250 | func\n pgmq   | send                   | bigint                                                                                                                                                           | queue_name text, message jsonb, delay integer DEFAULT 0                                                              | func\n pgmq   | send_batch             | TABLE(msg_id bigint)                                                                                                                                             | queue_name text, messages jsonb[], delay integer DEFAULT 0                                                           | func\n pgmq   | set_vt                 | TABLE(msg_id bigint, read_ct integer, enqueued_at timestamp with time zone, vt timestamp with time zone, message jsonb)                                          | queue_name text, msg_id bigint, vt_offset integer                                                                    | func\n(18 rows)\n")),(0,i.kt)("p",null,"With this, we can now explore the extension from the inside. And, if needed, recompile and reinstall the extension to play with it."),(0,i.kt)("h2",{id:"the-internals"},"The internals"),(0,i.kt)("p",null,"We know that when an extension is created with pgrx, it generates a ",(0,i.kt)("inlineCode",{parentName:"p"},"lib.rs")," file. Let us explore it."),(0,i.kt)("p",null,"One of the first thing we can see, is that the other five files in the ",(0,i.kt)("inlineCode",{parentName:"p"},"src/")," directory are included:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub mod api;\npub mod errors;\npub mod metrics;\npub mod partition;\npub mod util;\n")),(0,i.kt)("p",null,"After reviewing these files a little bit, we can notice that there's also some relevant code in another module, the one in ",(0,i.kt)("inlineCode",{parentName:"p"},"core/"),". For example, in ",(0,i.kt)("inlineCode",{parentName:"p"},"src/partition.rs"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"use pgmq_core::{\n    errors::PgmqError,\n    query::{\n        assign_archive, assign_queue, create_archive, create_archive_index, create_index,\n        create_meta, grant_pgmon_meta, grant_pgmon_queue, grant_pgmon_queue_seq, insert_meta,\n    },\n    types::{PGMQ_SCHEMA, QUEUE_PREFIX},\n    util::CheckedName,\n};\n")),(0,i.kt)("p",null,"So, at this point we know that we can find the source code in two places: ",(0,i.kt)("inlineCode",{parentName:"p"},"src/")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"core/"),". "),(0,i.kt)("p",null,"If we continue exploring ",(0,i.kt)("inlineCode",{parentName:"p"},"lib.rs"),", we can see that a sql file (",(0,i.kt)("inlineCode",{parentName:"p"},"sql_src.sql"),") is executed when the extension is enabled:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"CREATE TABLE pgmq.meta (\n    queue_name VARCHAR UNIQUE NOT NULL,\n    is_partitioned BOOLEAN NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL\n);\n...\n")),(0,i.kt)("p",null,"We can actually see that table with ",(0,i.kt)("inlineCode",{parentName:"p"},"psql"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"-- List tables in the pgmq schema\n\\dt pgmq.*\n\n-- List contents of pgmq.meta\nselect * from pgmq.meta;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"pgmq-# \\dt pgmq.*\n           List of relations\n Schema | Name | Type  |  Owner\n--------+------+-------+----------\n public | meta | table | binidxaba\n(1 row)\n\npgmq=# select * from pgmq.meta;\n queue_name | created_at\n------------+------------\n(0 rows)\n")),(0,i.kt)("p",null,"The following diagram shows what the pgmq schema looks like right after ",(0,i.kt)("inlineCode",{parentName:"p"},"CREATE EXTENSION")," is executed:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"after-create-extension",src:n(48434).Z,title:"after create extension",width:"596",height:"551"})),(0,i.kt)("p",null,"From this point, we can suspect that every time we create a queue, a new row is inserted into this table."),(0,i.kt)("p",null,"Let us see what ",(0,i.kt)("inlineCode",{parentName:"p"},"pgmq.create()")," does..."),(0,i.kt)("h3",{id:"pgmqcreate"},"pgmq.create()"),(0,i.kt)("p",null,"Most of the functions provided by pgmq are defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"src/api.rs"),". In that file, we can find the function ",(0,i.kt)("inlineCode",{parentName:"p"},"pgmq_create(queue_name: &str)"),", and if we chase the call sequence, we can discover that the interesting function is ",(0,i.kt)("inlineCode",{parentName:"p"},"init_queue(name: &str)")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"core/src/query.rs"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn init_queue(name: &str) -> Result<Vec<String>, PgmqError> {\n    let name = CheckedName::new(name)?;\n    Ok(vec![\n        create_queue(name)?,\n        assign_queue(name)?,\n        create_index(name)?,\n        create_archive(name)?,\n        assign_archive(name)?,\n        create_archive_index(name)?,\n        insert_meta(name)?,\n        grant_pgmon_queue(name)?,\n    ])\n}\n")),(0,i.kt)("p",null,"This function generates several sql statements that are later executed in ",(0,i.kt)("inlineCode",{parentName:"p"},"pgmq_create_non_partitioned")," using an ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/pgx/latest/pgx/spi/struct.SpiClient.html"},(0,i.kt)("inlineCode",{parentName:"a"},"Spi")," client"),"."),(0,i.kt)("p",null,"I'll skip the details, but the sql statements basically do:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Create a table ",(0,i.kt)("inlineCode",{parentName:"li"},"pgmq.q_<queue_name>"),"."),(0,i.kt)("li",{parentName:"ol"},"Assign the table to the pqmg extension."),(0,i.kt)("li",{parentName:"ol"},"Create an index on the ",(0,i.kt)("inlineCode",{parentName:"li"},"pgmq.q_<queue_name>")," table."),(0,i.kt)("li",{parentName:"ol"},"Create a table ",(0,i.kt)("inlineCode",{parentName:"li"},"pgmq.a_<queue_name>"),"."),(0,i.kt)("li",{parentName:"ol"},"Assign the table to the pgmq extension."),(0,i.kt)("li",{parentName:"ol"},"Create an index on the ",(0,i.kt)("inlineCode",{parentName:"li"},"pgmq.a_<queue_name>")," table."),(0,i.kt)("li",{parentName:"ol"},"Insert a row on the ",(0,i.kt)("inlineCode",{parentName:"li"},"pgmq.meta")," table."),(0,i.kt)("li",{parentName:"ol"},"Grant privileges to ",(0,i.kt)("inlineCode",{parentName:"li"},"pg_monitor"),".")),(0,i.kt)("p",null,"We can see the effects of this in psql using the following lines:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"-- Create a queue\nselect pgmq.create('my_queue');\n\n-- List tables\n\\dt pgmq.*\n\n-- List indexes\n\\di pgmq.*\n\n-- See the contents of pgmq_meta\nselect * from pgmq.meta;\n")),(0,i.kt)("p",null,"The output will show something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"pgmq=# select pgmq_create('my_queue');\n create\n--------\n\n(1 row)\n\npgmq=# \\dt pgmq.*;\n           List of relations\n Schema |    Name    | Type  |  Owner\n--------+------------+-------+-----------\n pgmq   | a_my_queue | table | binidxaba\n pgmq   | meta       | table | binidxaba\n pgmq   | q_my_queue | table | binidxaba\n(3 rows)\n\npgmq=# \\di pgmq.*\n                         List of relations\n Schema |           Name           | Type  |   Owner   |   Table\n--------+--------------------------+-------+-----------+------------\n pgmq   | a_my_queue_pkey          | index | binidxaba | a_my_queue\n pgmq   | archived_at_idx_my_queue | index | binidxaba | a_my_queue\n pgmq   | meta_queue_name_key      | index | binidxaba | meta\n pgmq   | q_my_queue_pkey          | index | binidxaba | q_my_queue\n pgmq   | q_my_queue_vt_idx        | index | binidxaba | q_my_queue\n(5 rows)\n\npgmq=# select * from pgmq.meta;\n queue_name | is_partitioned |          created_at           \n ------------+----------------+-------------------------------\n  my_queue   | f              | 2023-09-18 23:35:38.163096-06\n  (1 row)\n")),(0,i.kt)("p",null,"The following diagram shows what the pgmq schema looks like at this point:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"complete",src:n(71666).Z,title:"after create queue",width:"596",height:"551"})),(0,i.kt)("p",null,"For the queue ",(0,i.kt)("inlineCode",{parentName:"p"},"my_queue"),", we can see the underlying table and the corresponding archive table. Each table has an index associated with the primary key. The ",(0,i.kt)("inlineCode",{parentName:"p"},"pgmq.q_my_queue")," table also has an index on the ",(0,i.kt)("inlineCode",{parentName:"p"},"vt")," column, and ",(0,i.kt)("inlineCode",{parentName:"p"},"pgmq.a_my_queue")," has an index on the ",(0,i.kt)("inlineCode",{parentName:"p"},"archived_at")," column."),(0,i.kt)("p",null,"We can suspect that the ",(0,i.kt)("inlineCode",{parentName:"p"},"pgmq.q_my_queue")," table is used in the send and read operations. Let us look at those two functions."),(0,i.kt)("h3",{id:"pgmqsend"},"pgmq.send()"),(0,i.kt)("p",null,"We can explore the send operation in a similar way. The relevant SQL is straightforward. It just inserts a new row in the the underlying table:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO {PGMQ_SCHEMA}.{QUEUE_PREFIX}_{name} (vt, message)\nVALUES {values}\nRETURNING msg_id; \n")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"pgmq-send",src:n(68571).Z,title:"what send does",width:"596",height:"624"})),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"At this point, we can see the following pattern in the pgmq project: "),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"the exposed SQL functions are defined in ",(0,i.kt)("inlineCode",{parentName:"li"},"src/api.rs"),", and "),(0,i.kt)("li",{parentName:"ul"},"the underlying SQL statements are defined in ",(0,i.kt)("inlineCode",{parentName:"li"},"core/src/query.rs")))),(0,i.kt)("h3",{id:"pgmqread"},"pgmq.read()"),(0,i.kt)("p",null,"So, let's see. If I were the one programming ",(0,i.kt)("inlineCode",{parentName:"p"},"pgmq.read()"),', I would perhaps do something like "get the first ',(0,i.kt)("inlineCode",{parentName:"p"},"{limit}")," rows from the queue table whose ",(0,i.kt)("inlineCode",{parentName:"p"},"{vt}")," has already expired, and for those rows, also update the visibility timeout to ",(0,i.kt)("inlineCode",{parentName:"p"},"now() + {vt}"),'." Naively, maybe something like:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"update pgmq.q_my_queue\nSET      \n    vt = clock_timestamp() + interval '10 seconds',                                            \n    read_ct = read_ct + 1                                                                      \nWHERE  \n    msg_id in (select msg_id from pgmq.q_my_queue where vt <= clock_timestamp()                                                      \n        ORDER BY msg_id ASC                                                                            \n        LIMIT 1);  \n")),(0,i.kt)("p",null,"In reality, ",(0,i.kt)("inlineCode",{parentName:"p"},"pgmq.read")," is more interesting than that \ud83d\ude05. It performs the following DML:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"WITH cte AS\n    (\n        SELECT msg_id\n        FROM {PGMQ_SCHEMA}.{QUEUE_PREFIX}_{name}\n        WHERE vt <= clock_timestamp()\n        ORDER BY msg_id ASC\n        LIMIT {limit}\n        FOR UPDATE SKIP LOCKED\n    )\nUPDATE {PGMQ_SCHEMA}.{QUEUE_PREFIX}_{name} t\nSET\n    vt = clock_timestamp() + interval '{vt} seconds',\n    read_ct = read_ct + 1\nFROM cte\nWHERE t.msg_id=cte.msg_id\nRETURNING *;\n")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"pgmq-read",src:n(11980).Z,title:"what read does",width:"596",height:"624"})),(0,i.kt)("p",null,"Firstly, in pgmq's version, there is a CTE (Common Table Expression) to obtain the first ",(0,i.kt)("inlineCode",{parentName:"p"},"{limit}")," message IDs whose ",(0,i.kt)("inlineCode",{parentName:"p"},"vt")," has expired. (It would be interesting to discuss why pgmq developers used a CTE, but we can explore that in another post.)"),(0,i.kt)("p",null,"There are two crucial things to notice in the CTE. One is the ",(0,i.kt)("inlineCode",{parentName:"p"},"order by")," clause that ensures the FIFO ordering. The other one is the ",(0,i.kt)("inlineCode",{parentName:"p"},"FOR UPDATE SKIP LOCKED")," clause, claiming the rows no one else has claimed. This part is essential because it ensures correctness in the case of concurrent  ",(0,i.kt)("inlineCode",{parentName:"p"},"pgmq.read()")," operations. "),(0,i.kt)("p",null,"The next step in the DML is to update the corresponding rows with a new vt value by adding the supplied ",(0,i.kt)("inlineCode",{parentName:"p"},"{vt}")," to the current timestamp. Additionally, the ",(0,i.kt)("inlineCode",{parentName:"p"},"read_ct")," value is incremented by 1. What is the use of this counter? In general, we can suspect that there is a problem processing a given message if it has a high ",(0,i.kt)("inlineCode",{parentName:"p"},"read_ct")," value because users usually archive the message after successfully processing it. So, ideally, a message is only read once. "),(0,i.kt)("h3",{id:"pgmqarchive"},"pgmq.archive()"),(0,i.kt)("p",null,"The next stage in the lifecycle of a message is archiving it. For that, pgmq uses the following insert statement:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"WITH archived AS (\n    DELETE FROM {PGMQ_SCHEMA}.{QUEUE_PREFIX}_{name}\n    WHERE msg_id = ANY($1)\n    RETURNING msg_id, vt, read_ct, enqueued_at, message\n)\nINSERT INTO {PGMQ_SCHEMA}.{ARCHIVE_PREFIX}_{name} (msg_id, vt, read_ct, enqueued_at, message)\nSELECT msg_id, vt, read_ct, enqueued_at, message\nFROM archived\nRETURNING msg_id;\n")),(0,i.kt)("p",null,"Essentially, it deletes the message with the provided ",(0,i.kt)("inlineCode",{parentName:"p"},"msg_id")," from the queue table, and then the message is placed in the corresponding archive table."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"pgmq-archive",src:n(3057).Z,title:"what archive does",width:"596",height:"624"})),(0,i.kt)("p",null,"One interesting thing to notice is that ",(0,i.kt)("inlineCode",{parentName:"p"},"pgmq.archive()")," can be used to archive a batch of messages too:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select pgmq.archive('my_queue', ARRAY[3, 4, 5]);\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"pgmq=# select pgmq.archive('my_queue', ARRAY[3, 4, 5]);\n pgmq_archive\n--------------\n t\n t\n t\n(3 rows)\n\n")),(0,i.kt)("p",null,"That is achieved in pgrx by declaring two functions using the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/pgcentralfoundation/pgrx/blob/047b1d1fc9e9c4007c871e226fa81e294f8bf5e6/pgrx-macros/src/lib.rs#L462"},"same name in the ",(0,i.kt)("inlineCode",{parentName:"a"},"pg_extern"))," derive macro as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[pg_extern(name = "archive")]\nfn pgmq_archive(queue_name: &str, msg_id: i64) -> Result<Option<bool>, PgmqExtError> {\n//...\n}\n\n#[pg_extern(name = "archive")]\nfn pgmq_archive_batch(\n    queue_name: &str,\n    msg_ids: Vec<i64>,\n) -> Result<TableIterator<\'static, (name!(archive, bool),)>, PgmqExtError> {\n//...\n}\n')),(0,i.kt)("h3",{id:"pgmqdrop_queue"},"pgmq.drop","_","queue()"),(0,i.kt)("p",null,"Finally, let's talk about ",(0,i.kt)("inlineCode",{parentName:"p"},"pgmq.drop_queue()"),". It essentially executes multiple statements:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Unassign the ",(0,i.kt)("inlineCode",{parentName:"li"},"pgmq.q_<queue_name>")," table from the extension."),(0,i.kt)("li",{parentName:"ol"},"Unassign the ",(0,i.kt)("inlineCode",{parentName:"li"},"pgmq.a_<queue_name>")," table from the extension."),(0,i.kt)("li",{parentName:"ol"},"Drop the table ",(0,i.kt)("inlineCode",{parentName:"li"},"pgmq.q_<queue_name>"),"."),(0,i.kt)("li",{parentName:"ol"},"Drop the table ",(0,i.kt)("inlineCode",{parentName:"li"},"pgmq.a_<queue_name>"),"."),(0,i.kt)("li",{parentName:"ol"},"Delete the corresponding row from the ",(0,i.kt)("inlineCode",{parentName:"li"},"pgmq.meta")," table.")),(0,i.kt)("p",null,"Nothing surprising in this one, and with it, we conclude our tour."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"In this post, we explored how the pgrx tool is used to generate the pgmq extension. We explored how the metadata objects are created and how they are used in the basic send, read and archive operations. At least from an explorer perspective, the internals of the extension are currently easy to read and understand."),(0,i.kt)("p",null,"I invite everyone to explore how the other pgmq functions work. You can explore the code at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tembo-io/pgmq"},"https://github.com/tembo-io/pgmq"),". And you can learn more about pgrx at: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/pgcentralfoundation/pgrx"},"https://github.com/pgcentralfoundation/pgrx"),"."))}u.isMDXComponent=!0},48434:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/after-create-extension-e590194728d15b0433b8e5510725f9ff.png"},71666:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/complete-0b9cb3715d61904139d1d12fb7d717e6.png"},3057:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/pgmq-archive-30c5d9c4aaee1ce50a1ada784e3096e3.png"},11980:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/pgmq-read-b13515d2be7805a182167d1430faad87.png"},68571:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/pgmq-send-e0f2306ae56fdd9487889c5125c8b461.png"}}]);