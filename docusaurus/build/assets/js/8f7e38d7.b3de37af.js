"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1231],{3905:(e,t,s)=>{s.d(t,{Zo:()=>c,kt:()=>m});var o=s(67294);function r(e,t,s){return t in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}function n(e,t){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),s.push.apply(s,o)}return s}function a(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{};t%2?n(Object(s),!0).forEach((function(t){r(e,t,s[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):n(Object(s)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))}))}return e}function i(e,t){if(null==e)return{};var s,o,r=function(e,t){if(null==e)return{};var s,o,r={},n=Object.keys(e);for(o=0;o<n.length;o++)s=n[o],t.indexOf(s)>=0||(r[s]=e[s]);return r}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(o=0;o<n.length;o++)s=n[o],t.indexOf(s)>=0||Object.prototype.propertyIsEnumerable.call(e,s)&&(r[s]=e[s])}return r}var u=o.createContext({}),l=function(e){var t=o.useContext(u),s=t;return e&&(s="function"==typeof e?e(t):a(a({},t),e)),s},c=function(e){var t=l(e.components);return o.createElement(u.Provider,{value:t},e.children)},h="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var s=e.components,r=e.mdxType,n=e.originalType,u=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),h=l(s),p=r,m=h["".concat(u,".").concat(p)]||h[p]||g[p]||n;return s?o.createElement(m,a(a({ref:t},c),{},{components:s})):o.createElement(m,a({ref:t},c))}));function m(e,t){var s=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var n=s.length,a=new Array(n);a[0]=p;var i={};for(var u in t)hasOwnProperty.call(t,u)&&(i[u]=t[u]);i.originalType=e,i[h]="string"==typeof e?e:r,a[1]=i;for(var l=2;l<n;l++)a[l]=s[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,s)}p.displayName="MDXCreateElement"},72803:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>u,contentTitle:()=>a,default:()=>g,frontMatter:()=>n,metadata:()=>i,toc:()=>l});var o=s(87462),r=(s(67294),s(3905));const n={slug:"pgmq-self-regulating-queue",title:"PGMQ: Lightweight Message Queue on Postgres with No Background Worker",authors:["adam"],tags:["postgres","message-queue","pgmq"]},a=void 0,i={permalink:"/blog/pgmq-self-regulating-queue",editUrl:"https://github.com/tembo-io/website/blob/main/blog/2023-11-07-pgmq-self-regulating/index.md",source:"@site/blog/2023-11-07-pgmq-self-regulating/index.md",title:"PGMQ: Lightweight Message Queue on Postgres with No Background Worker",description:"image",date:"2023-11-07T00:00:00.000Z",formattedDate:"November 7, 2023",tags:[{label:"postgres",permalink:"/blog/tags/postgres"},{label:"message-queue",permalink:"/blog/tags/message-queue"},{label:"pgmq",permalink:"/blog/tags/pgmq"}],readingTime:5.705,hasTruncateMarker:!1,authors:[{name:"Adam Hendel",title:"Founding Engineer",url:"https://github.com/ChuckHend",email:"noreply@tembo.io",imageURL:"https://github.com/chuckhend.png",key:"adam"}],frontMatter:{slug:"pgmq-self-regulating-queue",title:"PGMQ: Lightweight Message Queue on Postgres with No Background Worker",authors:["adam"],tags:["postgres","message-queue","pgmq"]},prevItem:{title:"Hacking Postgres, Ep. 8: Philippe No\xebl",permalink:"/blog/hacking-postgres-ep8"},nextItem:{title:"Hacking Postgres Ep. 7: Burak Yucesoy",permalink:"/blog/hacking-postgres-ep7"}},u={authorsImageUrls:[void 0]},l=[{value:"FOR UPDATE: Ensuring Exclusive Access",id:"for-update-ensuring-exclusive-access",level:2},{value:"SKIP LOCKED: Keeping the Line Moving",id:"skip-locked-keeping-the-line-moving",level:2},{value:"Self-Regulating Queues in PostgreSQL",id:"self-regulating-queues-in-postgresql",level:2},{value:"Queue regulation isn\u2019t just for error modes",id:"queue-regulation-isnt-just-for-error-modes",level:2},{value:"Choose the simplest queue architecture with PGMQ",id:"choose-the-simplest-queue-architecture-with-pgmq",level:2}],c={toc:l},h="wrapper";function g(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("div",{style:{width:"75%"}},(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image",src:s(97251).Z,width:"822",height:"753"}))),(0,r.kt)("p",null,"Your app needs a message queue. Simple enough\u2014until you try to do it, anyway."),(0,r.kt)("p",null,"Go set it up on Kafka? Sure...but now you have a Kafka cluster to manage.\nRedis could work, but now you're just managing Redis instances instead.\nSQS? That means you have to reconfigure your application to talk to AWS, and you also get an extra external bill as icing on the cake.\nLet's build it on Postgres! However, if you follow most blogs and guides, you'll probably end up building an agent, watcher process, or background worker to make sure the queue stays healthy. It's better, but if the background worker fails, you could end up with bigger problems."),(0,r.kt)("p",null,"Fortunately, there's a better way."),(0,r.kt)("p",null,"By designing with a visibility timeout, we remove the need for external processes for queue management. PGMQ is a Postgres extension built following exactly this sort of self-regulating queue. Today we're going to combine PGMQ with pair of core Postgres features\u2014FOR UPDATE and SKIP LOCKED\u2014to cover all the needs of our message queue. FOR UPDATE helps ensure that just a single consumer receives a message in the queue. And SKIP LOCKED is required if you want to have multiple consumers on the same queue \u2013 without it each consumer would wait for the others to remove their locks. Before we put all the pieces together, let's do a quick refresher on how each of these works."),(0,r.kt)("h2",{id:"for-update-ensuring-exclusive-access"},"FOR UPDATE: Ensuring Exclusive Access"),(0,r.kt)("p",null,"Imagine a crowded store with a single cashier. As customers approach the counter, the cashier must serve them one at a time, ensuring each transaction is complete before moving on to the next. Similarly, when working with a queue, it's essential to ensure that only one process or transaction works with a particular row of data at a time. This is where FOR UPDATE comes into play."),(0,r.kt)("p",null,"The FOR UPDATE clause is used to lock selected rows, preventing other transactions from modifying or locking them until the current transaction ends. This ensures that once a task (or row in our queue) is picked up, it isn't grabbed by another worker or process simultaneously. It guarantees exclusive access, much like how our lone cashier attends to a single customer at a time."),(0,r.kt)("h2",{id:"skip-locked-keeping-the-line-moving"},"SKIP LOCKED: Keeping the Line Moving"),(0,r.kt)("p",null,"Back to our store analogy, if a customer isn't ready to check out and holds up the line, it can cause unnecessary delays for the other customers. What if, instead, those who aren't ready simply step aside, allowing others to continue? That would undoubtedly speed up the checkout process. This is the concept behind SKIP LOCKED."),(0,r.kt)("p",null,"When combined with FOR UPDATE, the SKIP LOCKED clause ensures that if a row is locked by another transaction, it gets skipped over, and the next available row is selected. This way, other workers or processes don't get stuck waiting for a locked row to be released; they simply move on to the next available task."),(0,r.kt)("p",null,"By using these two clauses together, you can ensure that tasks in your queue are processed smoothly and efficiently, with each task getting picked up by a single worker and other workers moving seamlessly to the next available task."),(0,r.kt)("p",null,"However, how can we take this one step further? Many queue implementations have us using FOR UPDATE to mark a message as \u201cin progress\u201d which is great. However, that typically requires us to have a service external to postgres which monitors the queue to check for messages which have been \u201cin progress\u201d for too long."),(0,r.kt)("h2",{id:"self-regulating-queues-in-postgresql"},"Self-Regulating Queues in PostgreSQL"),(0,r.kt)("p",null,"If you\u2019re using FOR UPDATE SKIP LOCKED, and setting messages \u201cin progress\u201d, you most likely need a process to watch your queue and check for messages that have been processing for too long. Rather than running a background worker or external process, PGMQ implements a Visibility Timeout (VT). A VT is a designated period during which a message, once read from the queue, becomes invisible to other consumers or workers. This ensures that once a worker picks up a task, other workers won't attempt to process the same task for the duration of this timeout. If the original worker fails to complete the task within the specified timeout, the task becomes visible again by nature of time elapsing past the specified VT, which means PGMQ still provides an at-least-once delivery guarantee even when the VT has elapsed. The task is ready for reprocessing by the same or a different worker."),(0,r.kt)("p",null,"In essence, the visibility timeout provides a grace period for tasks to be processed. It becomes a buffer against potential failures, ensuring that if a task isn\u2019t completed due to any unforeseen reasons, it doesn\u2019t get lost but rather re-enters the queue. Without something like the VT, queue systems will need to run a process to watch the queue. If that watcher crashes, or loses connection, then messages will stay unavailable until the watcher is recovered."),(0,r.kt)("h2",{id:"queue-regulation-isnt-just-for-error-modes"},"Queue regulation isn\u2019t just for error modes"),(0,r.kt)("p",null,"A common use case is for a consumer that needs to process a long-running I/O bound task. Let\u2019s say there is a message with a task to create some infrastructure in your favorite ",(0,r.kt)("a",{parentName:"p",href:"https://cloud.tembo.io"},"cloud provider"),", e.g. create an EC2 instance if it doesn\u2019t already exist. That could take minutes to start up. Your consumer can submit the request to provision EC2, and then instead of waiting for EC2 to create, it can set the VT on that message to 60 seconds from now, then move on to read the next message. In 60 seconds, the message will become visible again and can be picked up.  That can look something like the follow pseudo-code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"# read a message, make it invisible for 30 seconds\nselect pgmq.read(\u2018task_queue\u2019, 30, 1)\n\n...check if S3 bucket already already created\n...request to create S3 bucket if not exists\n\n# set message VT to 60 seconds from now If not exists: \nselect pgmq.set_vt(\u2018task_queue\u2019, <msg_id>, 60)\n\n# consumer archives or deletes the message when its finished with its job\nselect pgmq.archive('test_queue', <msg_id>)\n")),(0,r.kt)("p",null,"With PGMQ\u2019s design, messages do not leave the queue until they are explicitly archived or deleted, so you could think of using the VT directly as \u201creturning the message to the queue\u201d, even though it technically never left the queue. Rather, returning it to a state that can be read by other consumers."),(0,r.kt)("h2",{id:"choose-the-simplest-queue-architecture-with-pgmq"},"Choose the simplest queue architecture with PGMQ"),(0,r.kt)("p",null,"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"FOR UPDATE")," so that you ensure messages are only read by one consumer at time. ",(0,r.kt)("inlineCode",{parentName:"p"},"SKIP LOCKED")," so that you can have multiple workers processing messages concurrently. Finally, implement a visibility timeout so that you no longer need to rely on an external process to handle messages that have failed to process. Install the open-source ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/tembo-io/pgmq"},"PGMQ extension")," for Postgres or try it on ",(0,r.kt)("a",{parentName:"p",href:"https://cloud.tembo.io"},"Tembo Cloud")," today and immediately benefit from all of these design decisions."))}g.isMDXComponent=!0},97251:(e,t,s)=>{s.d(t,{Z:()=>o});const o=s.p+"assets/images/tembo-queue-805449fd409081b900fb16cefd7e52e5.png"}}]);