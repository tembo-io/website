"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9673],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>g});var n=r(67294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(r),d=i,g=m["".concat(l,".").concat(d)]||m[d]||u[d]||a;return r?n.createElement(g,o(o({ref:t},p),{},{components:r})):n.createElement(g,o({ref:t},p))}));function g(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<a;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},39924:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>m,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>p,toc:()=>u});var n=r(87462),i=(r(67294),r(3905));const a=r.p+"assets/images/access-matrix-element-38e91e548e9b8577be311473355f5277.png",o=r.p+"assets/images/array-functions-on-matrices-641a4774ad1b0f8cb735fffb4f904a87.png",s=r.p+"assets/images/create-matrices-9e4f488982e7e45e509ba4fd1d25e879.png",l={sidebar_position:2,tags:["Postgres Basics"]},c="How to work with matrices in Postgres",p={unversionedId:"postgres_guides/how-to-work-with-matrices-in-postgres/how-to-work-with-matrices-in-postgres",id:"postgres_guides/how-to-work-with-matrices-in-postgres/how-to-work-with-matrices-in-postgres",title:"How to work with matrices in Postgres",description:"Working with matrices in PostgreSQL opens a world of possibilities for managing structured data. Whether you're dealing with scientific data, financial models, or any other multidimensional datasets, PostgreSQL provides powerful tools and techniques to store, manipulate, and query matrices efficiently.",source:"@site/docs/postgres_guides/how-to-work-with-matrices-in-postgres/how-to-work-with-matrices-in-postgres.md",sourceDirName:"postgres_guides/how-to-work-with-matrices-in-postgres",slug:"/postgres_guides/how-to-work-with-matrices-in-postgres/",permalink:"/docs/postgres_guides/how-to-work-with-matrices-in-postgres/",draft:!1,editUrl:"https://github.com/tembo-io/website/blob/main/docs/postgres_guides/how-to-work-with-matrices-in-postgres/how-to-work-with-matrices-in-postgres.md",tags:[{label:"Postgres Basics",permalink:"/docs/tags/postgres-basics"}],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,tags:["Postgres Basics"]},sidebar:"tutorialSidebar",previous:{title:"How to use PostgreSQL arrays",permalink:"/docs/postgres_guides/how-to-use-postgresql-arrays/"},next:{title:"Listing all connections to Postgres",permalink:"/docs/postgres_guides/listing-all-connections-in-postgres/"}},m={},u=[{value:"Creating a matrix in Postgres",id:"creating-a-matrix-in-postgres",level:2},{value:"Matrix Storage in Tables",id:"matrix-storage-in-tables",level:2},{value:"Accessing elements",id:"accessing-elements",level:2},{value:"Operations on Matrices",id:"operations-on-matrices",level:2},{value:"Matrix manipulation",id:"matrix-manipulation",level:2},{value:"Conclusion",id:"conclusion",level:2}],d={toc:u},g="wrapper";function h(e){let{components:t,...r}=e;return(0,i.kt)(g,(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"how-to-work-with-matrices-in-postgres"},"How to work with matrices in Postgres"),(0,i.kt)("p",null,"Working with matrices in PostgreSQL opens a world of possibilities for managing structured data. Whether you're dealing with scientific data, financial models, or any other multidimensional datasets, PostgreSQL provides powerful tools and techniques to store, manipulate, and query matrices efficiently."),(0,i.kt)("p",null,"Matrices consist of arrays organized in a two-dimensional plane to store data in rows and columns. As a result, they operate much like arrays do within PostgreSQL. (Check our ",(0,i.kt)("a",{parentName:"p",href:"https://tembo.io/docs/postgres_guides/how-to-use-postgresql-arrays/"},"guide")," to learn more about using arrays in Postgres.)"),(0,i.kt)("p",null,"This guide will walk you through the essentials of working with matrices in PostgreSQL."),(0,i.kt)("h2",{id:"creating-a-matrix-in-postgres"},"Creating a matrix in Postgres"),(0,i.kt)("p",null,"As we mentioned, matrix is just a 2-D array, therefore you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ARRAY")," constructor to create a matrix in Postgres. Here\u2019s an example of 2x2 matrix:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"SELECT ARRAY[ARRAY[1, 2], ARRAY[3, 4]] AS matrix1;\n")),(0,i.kt)("img",{src:s,width:"600",alt:"Creatematrices"}),(0,i.kt)("p",null,"In this example, we have used 2 ",(0,i.kt)("inlineCode",{parentName:"p"},"ARRAY")," constructors (",(0,i.kt)("inlineCode",{parentName:"p"},"ARRAY[1,2]"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ARRAY[3,4]"),") inside of an ",(0,i.kt)("inlineCode",{parentName:"p"},"ARRAY")," constructor. ",(0,i.kt)("inlineCode",{parentName:"p"},"matrix1")," is the name of the column holding this matrix."),(0,i.kt)("h2",{id:"matrix-storage-in-tables"},"Matrix Storage in Tables"),(0,i.kt)("p",null,'In Postgres it\u2019s possible to use "matrix" as a data type for a column in a table. You can create a column in the table and store matrix format data in it, like this:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"CREATE TABLE matrix_table (\n    id serial PRIMARY KEY,\n    data INT[][]\n);\n")),(0,i.kt)("p",null,"In this example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," column is of type integer matrix, but you can use any data type as the element type when defining matrices."),(0,i.kt)("p",null,"Once your matrix is created, you can follow the traditional method to insert values into it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"INSERT INTO matrix_table (data)\nVALUES (ARRAY[ARRAY[1, 2, 3], ARRAY[4, 5, 6]]);\n")),(0,i.kt)("h2",{id:"accessing-elements"},"Accessing elements"),(0,i.kt)("p",null,"You can also specify each element present in the matrix individually by specifying the row and column indices for that element. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"SELECT data[2][1] FROM matrix_table;\n")),(0,i.kt)("img",{src:a,width:"600",alt:"AccessMatrix"}),(0,i.kt)("p",null,"In this example, we have specified the row index ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," and column index ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,i.kt)("h2",{id:"operations-on-matrices"},"Operations on Matrices"),(0,i.kt)("p",null,"Postgres does not come with built-in functions to perform operations on matrices, so defining matrix operations can be quite verbose. In general, to operate efficiently on matrices, we recommend creating custom SQL and PL/SQL functions."),(0,i.kt)("p",null,"Here\u2019s an example of a function to add two matrices of size 2 by 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"CREATE FUNCTION add_matrices(matrix1 INT[], matrix2 INT[])\nRETURNS INT[] AS $$\nDECLARE\n    result INT[];\nBEGIN\n    result := ARRAY[ARRAY[matrix1[1][1] + matrix2[1][1], matrix1[1][2] + matrix2[1][2]],\n                    ARRAY[matrix1[2][1] + matrix2[2][1], matrix1[2][2] + matrix2[2][2]]];\n    RETURN result;\nEND;\n$$ LANGUAGE plpgsql;\n")),(0,i.kt)("h2",{id:"matrix-manipulation"},"Matrix manipulation"),(0,i.kt)("p",null,"PostgreSQL includes some array functions that can be used to manipulate matrices. For example, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ARRAY_AGG")," function to transpose a matrix:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"SELECT ARRAY_AGG(value ORDER BY rownum, colnum) AS transposed_matrix\nFROM my_matrix;\n")),(0,i.kt)("img",{src:o,width:"600",alt:"ArrayFunctions"}),(0,i.kt)("p",null,"Here, ",(0,i.kt)("inlineCode",{parentName:"p"},"ARRAY_AGG")," is an array function that we have applied on a matrix to perform the operation. However it's important to know that not every array function will work on matrices. To see a comprehensive list of array functions and operators, see the official ",(0,i.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/functions-array.html"},"PostgreSQL documentation"),"."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"In this guide, we explored the matrices and how you can work with them in Postgres."),(0,i.kt)("p",null,"Struggling to connect Postgres to your project? We're here to help. Have a look at our guides ",(0,i.kt)("a",{parentName:"p",href:"https://tembo.io/docs/category/postgres-guides"},"guides")," for more ideas and assistance in working with Postgres."))}h.isMDXComponent=!0}}]);