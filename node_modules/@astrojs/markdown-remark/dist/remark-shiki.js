import { bundledLanguages, getHighlighter } from "shikiji";
import { visit } from "unist-util-visit";
const ASTRO_COLOR_REPLACEMENTS = {
  "#000001": "var(--astro-code-color-text)",
  "#000002": "var(--astro-code-color-background)",
  "#000004": "var(--astro-code-token-constant)",
  "#000005": "var(--astro-code-token-string)",
  "#000006": "var(--astro-code-token-comment)",
  "#000007": "var(--astro-code-token-keyword)",
  "#000008": "var(--astro-code-token-parameter)",
  "#000009": "var(--astro-code-token-function)",
  "#000010": "var(--astro-code-token-string-expression)",
  "#000011": "var(--astro-code-token-punctuation)",
  "#000012": "var(--astro-code-token-link)"
};
const COLOR_REPLACEMENT_REGEX = new RegExp(
  `(${Object.keys(ASTRO_COLOR_REPLACEMENTS).join("|")})`,
  "g"
);
const highlighterCacheAsync = /* @__PURE__ */ new Map();
function remarkShiki({
  langs = [],
  theme = "github-dark",
  experimentalThemes = {},
  wrap = false
} = {}) {
  const themes = experimentalThemes;
  const cacheId = Object.values(themes).map((t) => typeof t === "string" ? t : t.name ?? "").join(",") + (typeof theme === "string" ? theme : theme.name ?? "") + langs.map((l) => l.name ?? l.id).join(",");
  let highlighterAsync = highlighterCacheAsync.get(cacheId);
  if (!highlighterAsync) {
    highlighterAsync = getHighlighter({
      langs: langs.length ? langs : Object.keys(bundledLanguages),
      themes: Object.values(themes).length ? Object.values(themes) : [theme]
    });
    highlighterCacheAsync.set(cacheId, highlighterAsync);
  }
  return async (tree) => {
    const highlighter = await highlighterAsync;
    visit(tree, "code", (node) => {
      let lang;
      if (typeof node.lang === "string") {
        const langExists = highlighter.getLoadedLanguages().includes(node.lang);
        if (langExists) {
          lang = node.lang;
        } else {
          console.warn(`The language "${node.lang}" doesn't exist, falling back to plaintext.`);
          lang = "plaintext";
        }
      } else {
        lang = "plaintext";
      }
      let themeOptions = Object.values(themes).length ? { themes } : { theme };
      let html = highlighter.codeToHtml(node.value, { ...themeOptions, lang });
      html = html.replace(/<pre class="(.*?)shiki(.*?)"/, `<pre class="$1astro-code$2"`);
      if (node.lang === "diff") {
        html = html.replace(
          /<span class="line"><span style="(.*?)">([\+|\-])/g,
          '<span class="line"><span style="$1"><span style="user-select: none;">$2</span>'
        );
      }
      if (wrap === false) {
        html = html.replace(/style="(.*?)"/, 'style="$1; overflow-x: auto;"');
      } else if (wrap === true) {
        html = html.replace(
          /style="(.*?)"/,
          'style="$1; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"'
        );
      }
      const themeName = typeof theme === "string" ? theme : theme.name;
      if (themeName === "css-variables") {
        html = html.replace(/style="(.*?)"/g, (m) => replaceCssVariables(m));
      }
      node.type = "html";
      node.value = html;
      node.children = [];
    });
  };
}
function replaceCssVariables(str) {
  return str.replace(COLOR_REPLACEMENT_REGEX, (match) => ASTRO_COLOR_REPLACEMENTS[match] || match);
}
export {
  remarkShiki
};
