"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.editShouldBeInFrontmatter = exports.getOpenFrontmatterEdit = exports.getNewFrontmatterEdit = exports.ensureRangeIsInFrontmatter = exports.ensureProperEditForFrontmatter = exports.isInsideFrontmatter = exports.isInsideExpression = exports.isInComponentStartTag = exports.isPossibleComponent = exports.isJSDocument = void 0;
const vscode_html_languageservice_1 = require("vscode-html-languageservice");
function isJSDocument(languageId) {
    return (languageId === 'javascript' ||
        languageId === 'typescript' ||
        languageId === 'javascriptreact' ||
        languageId === 'typescriptreact');
}
exports.isJSDocument = isJSDocument;
/**
 * Return true if a specific node could be a component.
 * This is not a 100% sure test as it'll return false for any component that does not match the standard format for a component
 */
function isPossibleComponent(node) {
    return !!node.tag?.[0].match(/[A-Z]/) || !!node.tag?.match(/.+[.][A-Z]?/);
}
exports.isPossibleComponent = isPossibleComponent;
/**
 * Return if a given offset is inside the start tag of a component
 */
function isInComponentStartTag(html, offset) {
    const node = html.findNodeAt(offset);
    return isPossibleComponent(node) && (!node.startTagEnd || offset < node.startTagEnd);
}
exports.isInComponentStartTag = isInComponentStartTag;
/**
 * Return if a given position is inside a JSX expression
 */
function isInsideExpression(html, tagStart, position) {
    const charactersInNode = html.substring(tagStart, position);
    return charactersInNode.lastIndexOf('{') > charactersInNode.lastIndexOf('}');
}
exports.isInsideExpression = isInsideExpression;
/**
 * Return if a given offset is inside the frontmatter
 */
function isInsideFrontmatter(offset, frontmatter) {
    switch (frontmatter.status) {
        case 'closed':
            return offset > frontmatter.position.start.offset && offset < frontmatter.position.end.offset;
        case 'open':
            return offset > frontmatter.position.start.offset;
        case 'doesnt-exist':
            return false;
    }
}
exports.isInsideFrontmatter = isInsideFrontmatter;
function ensureProperEditForFrontmatter(edit, frontmatter, newLine, position = 'top') {
    switch (frontmatter.status) {
        case 'open':
            return getOpenFrontmatterEdit(edit, newLine);
        case 'closed':
            return {
                newText: edit.newText,
                range: ensureRangeIsInFrontmatter(edit.range, frontmatter, position),
            };
        case 'doesnt-exist':
            return getNewFrontmatterEdit(edit, newLine);
    }
}
exports.ensureProperEditForFrontmatter = ensureProperEditForFrontmatter;
/**
 * Force a range to be at the start of the frontmatter if it is outside
 */
function ensureRangeIsInFrontmatter(range, frontmatter, position = 'top') {
    if (frontmatter.status === 'open' || frontmatter.status === 'closed') {
        // Q: Why not use PointToPosition?
        // A: The Astro compiler returns positions at the exact line where the frontmatter is, which is not adequate for mapping
        // edits as we want edits *inside* the frontmatter and not on the same line, or you would end up with things like `---import ...`
        const frontmatterStartPosition = {
            line: frontmatter.position.start.line,
            character: frontmatter.position.start.column - 1,
        };
        const frontmatterEndPosition = frontmatter.position.end
            ? { line: frontmatter.position.end.line - 1, character: 0 }
            : undefined;
        // If the range start is outside the frontmatter, return a range at the start of the frontmatter
        if (range.start.line < frontmatterStartPosition.line ||
            (frontmatterEndPosition && range.start.line > frontmatterEndPosition.line)) {
            if (frontmatterEndPosition && position === 'bottom') {
                return vscode_html_languageservice_1.Range.create(frontmatterEndPosition, frontmatterEndPosition);
            }
            return vscode_html_languageservice_1.Range.create(frontmatterStartPosition, frontmatterStartPosition);
        }
        return range;
    }
    return range;
}
exports.ensureRangeIsInFrontmatter = ensureRangeIsInFrontmatter;
function getNewFrontmatterEdit(edit, newLine) {
    edit.newText = `---${newLine}${edit.newText}---${newLine}${newLine}`;
    edit.range = vscode_html_languageservice_1.Range.create(0, 0, 0, 0);
    return edit;
}
exports.getNewFrontmatterEdit = getNewFrontmatterEdit;
function getOpenFrontmatterEdit(edit, newLine) {
    edit.newText = edit.newText.startsWith(newLine)
        ? `${edit.newText}---`
        : `${newLine}${edit.newText}---`;
    return edit;
}
exports.getOpenFrontmatterEdit = getOpenFrontmatterEdit;
// Most edits that are at 0:0, or outside the document are intended for the frontmatter
function editShouldBeInFrontmatter(range, astroDocument) {
    const isAtZeroZero = range.start.line === 0 && range.start.character === 0;
    const isPastFile = astroDocument && range.start.line > astroDocument.lineCount;
    const shouldIt = isAtZeroZero || isPastFile;
    return shouldIt
        ? { itShould: true, position: isPastFile ? 'bottom' : 'top' }
        : { itShould: false, position: undefined };
}
exports.editShouldBeInFrontmatter = editShouldBeInFrontmatter;
//# sourceMappingURL=utils.js.map